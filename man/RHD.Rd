% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/RHD.R
\name{RHD}
\alias{RHD}
\title{Regularized halfspace depth for functional data}
\usage{
RHD(
  x,
  X,
  tGrid,
  ld_mat = 0,
  prob_vec = 0.95,
  J_vec = round(nrow(X)^(1/(7 + 0.1))),
  f_iqr_vec = 1.5,
  M_vec = 1000L,
  M_type = 0L,
  ties = "min"
)
}
\arguments{
\item{x}{An n by p matrix of curves where the depths are evaluated. Each row represents one curve.}

\item{X}{An N by p matrix of observed curves that are used for constructing the depth function. Each row represents one observed curve.}

\item{tGrid}{A vector of p densely equi-spaced time grid points where the curve are evaluated.}

\item{ld_mat}{A matrix of regularization parameters. The number of rows should match the length of J_vec.}

\item{prob_vec}{A vector of numeric values in (0,1) that determines the regularization parameters for each truncation level in J_vec based on the RKHS norms from the randomly drawn directions. For each truncation level J in J_vec, (1000) potential random directions are drawn and its p-th quantile is determined as a regularization parameter, where p is a probability in prob_vec.}

\item{J_vec}{A vector of truncation levels used for estimating the covariance operator of the observed curves.}

\item{f_iqr_vec}{A vector of adjustment factors that are used for outlier detection methods linked to the RHD.}

\item{M_vec}{A vector of integers. Each integer represents the number of randomly drawn directions for rejection sampling approach to compute the RHD. The lengths of J_vec and M_vec should be equal.}

\item{M_type}{An integer 0 or 1. If M_type=0, the integers in M_vec mean the total number of drawn directions; if M_type=1, the integers in M_vec mean the number of accepted directions.}

\item{ties}{A character string specifying how ties are treated as rank function in R base.}
}
\value{
A list containing the following fields:
\item{depth}{Resulting depth values and depth rankings for each truncation level J and regularization parameter lambda.} 
\item{out}{The indices of outliers from the outlier detection method linked to the RHD for each truncation level J, regularization parameter lambda, and adjustment factor and f_iqr.}   
\item{ld_mat}{The matrix of regularization parameters that are used for computing the RHD.}
\item{RKHSnorm}{The RKHS norms of all randomly generated directions.}
\item{acpt_rate}{The rates of random directions whose RKHS norms are less than or equal to each regularization parameter.}
\item{M_vec}{The numbers of all randomly generated directions for each truncation level J.}
}
\description{
Compute depths and the associated rankings of the functional data from the regularizaed haflspace depth (RHD) and find outliers therein based on the outlier detection method linked to the RHD.
}
\examples{

# example

library(RHD)

# generating inlying smooth curves
J=15
c=2; a=5; dt = c*(1:J)^(-a)
g1 = c*VGAM::zeta(a)
ga = c(g1, sapply(1:(J-1), function(j){g1 - sum(dt[1:j])}))

# eigenfunctions
tt = 50; tGrid = seq(0, 1, len=tt); J=15
phi= t(fda::fourier(tGrid, J))

n = 50; s = sqrt(3)
xi = matrix(runif(n*J, -s, s), n, J) * runif(n, -s, s)
Xin = xi \%*\% (phi * sqrt(ga))


# outlying curves

eta = 3*sqrt(sum(ga))

fND = function(x){
 (x>=-0.05 & x<0.05) * (0.05*x) +
 (x>=0.05 & x<0.15) * (-0.05*(x-0.1)) +
 (x>=0.15 & x<0.25) * (0.05*(x-0.2)) +
 (x>=0.25 & x<0.35) * (-0.05*(x-0.3)) +
 (x>=0.35 & x<0.45) * (0.05*(x-0.4)) +
 (x>=0.45 & x<0.55) * (-0.05*(x-0.5)) +
 (x>=0.55 & x<0.65) * (0.05*(x-0.6)) +
 (x>=0.65 & x<0.75) * (-0.05*(x-0.7)) +
 (x>=0.75 & x<0.85) * (0.05*(x-0.8)) +
 (x>=0.85 & x<0.95) * (-0.05*(x-0.9)) +
 (x>=0.95 & x<1.05) * (0.05*(x-1))
}

XoutND = fND(tGrid)*eta*400*0.8   # non-differentiable curve

XoutLin = (2*tGrid-1)*eta*0.6     # linear curve


# apply the RHD

X = rbind(Xin[1:(n-2),], XoutND, XoutLin)

RHD(
  X, X, tGrid, 
  prob_vec = c(0.95), J_vec=c(6,10), f_iqr_vec=c(1.5, 3),
  M_vec=rep(1000,2)
  )


}
